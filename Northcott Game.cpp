/*nimm博弈 
一行的黑白棋子，把两个棋子之间的距离看做石子堆的石子个数，
间距缩小相当于拿走石子，增大相当于放棋子，但
是在这里如果他要增大两者的距离，说明必败，
如果不败的话，就不会去增大间距， 那么他的对手必胜。
所以这里把同一行棋子之间的距离看做石子数。 他
们的Nim和为0，先手必败，否则先手必胜。
*/
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n,m,a,b;
	int ans=0;
	while(cin>>n) {
		cin>>m;
		for(int i=1; i<=n; i++) {
			cin>>a>>b;
			ans^=abs(a-b)-1;
		}
		if(ans==0)
			cout<<"BAD LUCK!"<<endl;
		else
			cout<<"I WIN!"<<endl;
	}
	return 0;
}
/*题目描述

Tom和Jerry正在玩一种Northcott游戏，可是Tom老是输，因此他怀疑这个游戏是不是有某种必胜策略，郁闷的Tom现在向你求救了，你能帮帮他么？
游戏规则是这样的：
　　如图所示，游戏在一个n行m列（1 ≤ n ≤ 1000且2 ≤ m ≤ 100）的棋盘上进行，每行有一个黑子（黑方）和一个白子（白方）。执黑的一方先行，每次玩家可以移动己方的任何一枚棋子到同一行的任何一个空格上，当然这过程中不许越过该行的敌方棋子。双方轮流移动，直到某一方无法行动为止，移动最后一步的玩家获胜。Tom总是先下（黑方）。图1是某个初始局面，图二是Tom移动一个棋子后的局面（第一行的黑子左移两步）。


图1
 


图2
输入

输入数据有多组。每组数据第一行为两个整数n和m，由空格分开。接下来有n行，每行两个数Ti，Ji (1 ≤ Ti, Ji ≤ m)分别表示Tom和Jerry在该行棋子所处的列数。
注意：各组测试数据之间有不定数量的空行。你必须处理到文件末。
输出
对于每组测试数据输出一行你的结果。如果当前局面下Tom有必胜策略则输出“I WIN!”，否则输出“BAD LUCK!”。
样例输入

3 6
4 5
1 2
1 2

3 6
4 5
1 3
1 2

样例输出

BAD LUCK!
I WIN!
*/
